#### Автор - [Тарба Александр](https://vk.com/korotkoeimya1112)
#### Задание - [Методические указания](https://github.com/init/highload/blob/main/homework_architecture.md)

#### Содержание:
1. [Тема, функционал и аудитория](#1)
2. [Расчёт нагрузки](#2)
3. [Расчет глобальной нагрузки](#3)
4. [Расчет локальной нагрузки](#4)
5. [Логическая схема БД](#5)
6. [Физическая схема БД](#6)
7. [Алгоритм](#7)
8. [Технологии](#8)
9. [Обеспечение отказоустойчивости](#9)
10. [Схема проекта](#10)
11. [Список серверов](#11)
12. [Список источников](#12)

## Часть 1. Тема, функционал и аудитория <a name="1"></a>

### Тема курсовой работы - **"Проектирование высоконагруженнного сервиса голосового помощника"**
В качестве примера выбран [Google Ассистент](assistant.google.com)

### Ключевой функционал сервиса
- Создание напоминаний и уведомлений
- Поисковые запросы
- Прослушивание музыки

### Ключевые продуктовые решения
- Поддержка нескольких языков
- Хранение пользовательских событий на сервере
- Синхронизация пользователя на нескольких устройствах 
- Голосовой ввод запросов и озвучивание ответа 

### Целевая аудитория
- более 500 миллионов активных пользователей по всему миру [^1]

## Часть 2. Расчёт нагрузки <a name="2"></a>

### Продуктовые метрики
По статистике, приведенной в [^2], около 46% активных пользователей используют голосовой помощник ежедневно, таким образом можно оценить среднее число пользователей в день.


Пользователи выполняют $3.1$ миллиарда поисковых запросов в месяц [^2], из которых примерно 36% приходится на Google Assistant [^2], т.е. в месяц выполняется около $$3.11 млрд * 0.36 / 30 = 37.2млн~запросов/день.$$

Исследование, провденное в статье [^8] утверждает, что в случае с Google примерно 23.4% запросов приходятся на музыку. 

Зная процент, приходящийся на поисковые запросы и запросы воспроизведения музыки, можно составить пропорцию на число запросов воспроизведения музыки: $$37.2 млн * 0.234 / 0.36 = 24.8млн запросов/день.$$


<!-- Траффик по стриму звука можно рассчитать умножив объем кодированного звука в секунду на длительности стрима: $$25.2 * 320 = $$ -->

|Метрика|Значение|
|-------|--------|
|MAU|$500~млн пользователей$[^1]|
|DAU|$230~млн пользователей$[^2]|
|Число поисковых запросов в день|$37.2~млн$|
|Число запросов в день на музыку|$24.8~млн$|
|Средний размер хранилища для истории| $5185~Тб$|


### Технические метрики
#### Обоснование расчета технических метрик
Средняя длина английских слов составляет $5.43$ символа [^6].
Средняя длина ответа в Google Ассистенте согласно [^3] составляет 43 слова, а средняя длина вопроса составляет 29 слов [^4]. Таким образом суммарная длина запроса в символах составляет $(43+29)*5.43=391~символ$.

Таким образом для хранения ответа и вопроса необходимо $(43+29)*5.43=391~байт$. 

__Умножая на число запросов в день, получаем необходимый размер памяти для хранения текстов вопросов и ответов, т.е.:__ $$391 * 37.2млн = 14 546~Гб.$$

Согласно [^5] средняя скорость английской речи составлявет $170слов/минуту$ (английская речь относится к языкам с достаточно быстрым темпом речи, поэтому можно считать, что такая оценка является верхней границей реальных данных с учетом того, что большая часть запросов поступает на английском языке).

__Таким образом, можно оценить время озвучивания вопроса и ответа следующей формулой:__ $$(43+29)/170=0.42минут = 25.2~секунд$$

Объем звука рассчитывается по формуле: $$I = frkt,$$ где $f$ - частота дискретизации, $r$ - глубина кодирования, $k$ - количество каналов, $t$ - время кодирования [^7]. 

Согласно [^8] объем секунды звука в приемлемом качестве составляет $320~Кбайт/с$.

__Тогда средний объем траффика по запросу и ответу можно вычислить, умножив продожлительность записи звука на объем секунды звука, получим:__ $$25.2 * 320 = 8064~Кбайт.$$

Запрос воспроизведения музыки должен содержать команду для ассистента с указанием воспроизвести музыку, опционального указания группы и название песни или плейлиста.

Открытые данные по средней длине запроса на воспроизведение музки не обнародуются, поэтому с учетом того, что запрос на воспроизведения музыки должен содержать меньше слов, чем поисковой запрос, в связи с особенностями построения предложения на воспроизведения музыки, можно воспользоваться средней оценкой длины поискового запроса и считать ее мажорантной для случая с запросом на воспроизведение музыки.

Сервис голосового ассистента не замнимается транслированием музыки, поэтому запрос перенаправляется в другой сервис, специализирующийся на этом.

#### Расчет технических метрик
#### Расчет RPS
RPS по поисковым запросам рассчитывается следующим образом: $$37.2 * 10^6 / 24 / 60 / 60 = 430~запрос/c$$

RPS по запросам на музыку рассчитывается следующим образом: $$24.8 * 10^6 / 24 / 60 / 60 = 287~запрос/c$$

Положим, что пиковый RPS по поисковым запросам составляет $3/2$ от среднего, тогда пиковый RPS поисковых запросов: $$430 * 3 / 2 = 645~запроc/c.$$

Положим, что пиковый RPS по запросам на музыку составляет $3/2$ от среднего, тогда пиковый RPS поисковых запросов: $$287 * 3 / 2 = 431~запрос/c.$$

#### Расчет памяти
Объем памяти, необходимой для хранения истории запросов/ответов в год: $$14 546 Гб * 365 = 5185~Тб.$$

#### Расчет траффика
Положим, что пиковый траффик по поисковым запросам составляет $3/2$ от исходного, тогда пиковый траффик: $$(3/2 * 430) * 8064 * 1024 * 8 / 10^9 = 43~Гбит/c.$$

Положим, что пиковый траффик по запросам на музыку составляет $3/2$ от исходного, тогда пиковый траффик: $$(3/2 * 287) * 8064 * 1024 * 8 / 10^9 = 29~Гбит/c.$$

Суммарный суточный траффик по поисковым запросам, можно вычислить следующим образом: $$(37.2 * 10^6) * 8064 * 1024 / 1024 / 1024 / 1024 = 286084~Гбайт/сутки.$$

Суммарный суточный траффик по запросам на музыку, можно вычислить следующим образом: $$(24.8 * 10^6) * 8064 * 1024 / 1024 / 1024 / 1024 = 190723~Гбайт/сутки.$$

| Метрика                             | Значение        |
| ----------------------------------- | --------------- | 
| RPS по поисковым запросам           | $430~запрос/c$  |
| RPS по запросам на музыку           | $287~запрос/c$  |
| Пиковый RPS по поисковым  запросам  | $645~запрос/c$  |
| Пиковый RPS по запросам на музыку   | $431~запрос/c$  |
| Память                              |    $5185~Тб$    |
| Пиковый траффик по поисковым запросам|  $43~Гбит/c$   |
| Пиковый траффик по запросам на музыку|  $29~Гбит/c$   |
| Суточный траффик по поисковым запросам|$286084~Гбайт/сутки$|
| Суточный траффик по запросам на музыку|$190723~Гбайт/сутки$|


### Часть 3. Расчет глобальной нагрузки <a name="3"></a>
#### Расположение дата центров
Согласно [^10] основными пользователями голосовых ассистентов являются Америка, Европа и Китай, однако в Китае практически не используется Google Assistant в виду развитости собственных голосовых ассистентов. 
Также согласно [^11] примерно 37% американских жителей используют голосовой ассистент, что учитывая население Америки составляет 80% от общего числа пользователей головых ассистентов.
Таким образом дата центры должны располагаться в первую очередь в самых населенных городах на территории Америки и далее Европы, а также небольшая часть в удаленных местах, для ликвидации потенциальной возможности нагрузки сети медленными клиентами.

Американские дата центры:
- Нью-Йорк
- Сан-Франциско
- Сиэтл
- Даллас

Россия входит в топ 5 стран по числу запросов к Google Assistant [^10], поэтому для покрытия европейской части России, Сибири, Восточной части России и Японии целесообразно расположить их следующим образом:
- Москва
- Екатеринбург
- Владивосток

Есть статистика, утверждающая, что хинди, является вторым языком после английского по числу запросов к голосовому ассистенту (комментарий: потерял ссылку, и это вероятно связано с большим населением индии, так что не уверен, насколько целесообразно):
- Нью Дели

Удаленный дата центр для покрытия России и средней Азии:
- Алматы

Европа так же занимает большой процент рынка голосовых ассистентов:
- Лондон
- Париж 
- Стокгольм
- Берлин
- Стамбул (покрывает Азию, Северную Африку и Восточную Европу)

На юге Африки рассположим дата центр в наиболее экономически развитой стране (ЮАР):
- Претория

В Австралии:
- Сидней

#### Карта дата центров
![map](/src/dc_map1.png)
![map](/src/dc_map2.png)

#### Выбор алгоритма балансировки
Дата центры расположены так, что нет необходимости отправлять запрос с одного континента на другой, т.е. на каждом континенте имеется достаточное число дата центров для обслуживания запросов. 

В данном случае целесообразно использовать алгоритм **наименьшего времени отклика**, что позволит направлять запросы к серверам, которые менее нагружены в данный момент и могут быстрее ответить на запрос [^12]. 

Если сервера на континенте не перегружены, запрос будет отправляться внутри континента к серверу с наименьшем временем отклика, но если запросов будет слишком много, то запрос может быть отправлен в более свободный дата центр на другом, что позволит оптимизировать время отклика и избежать ситуации перегрузки дата центров, в случае резкого повышения нагрузки.

#### Технологии алгоритма балансировки
Балансировка будет происходить при первичном подключении к сервису (включении колонки/голосового ассистента). 
Далее устанавливается keep-alive соединение, которое не будет прерываться.

В качестве технологии для реализации маршрутизации DNS на основе **наименьшего времени отклика** будет использованы функции **Amazon Route 53** [^17].
Для использования данной технолгии достаточно указать и описать регионы, в которых расположены дата центры.
Остальную работу на себя берет данный сервис, отслеживая информацию о задержке до региона от конкретного клиента в реальном времени на основе своих внутренних данных [^17].
На основе этих данных сервис определяет регион с минимальной задержкой для пришедшего запроса. 

Для отслеживания метрик загруженности серверов будет использоваться Amazon CloudWatch [^18], таким образом необходимо развертывать приложения на AWS, с интегрированием Kubernetes [^19].

Данный подход позволит легко автоматизировать процесс развертки и обеспечения устойчивой работы приложений, а также сбора метрик.

#### Тенхолигический подход реализации переброски запросов
При помощи этих метрик будут отслеживаться перегруженные дата центры в регионах, используя RPS и загруженность CPU с какими-то весами определенными опытным путем.

Когда загруженность дата центра достигает определенной отметки, вес данного дата центра понижается, что при балансировке запросов позволяет отправлять на него меньше запросов или не отправлять вовсе.

При нормализации метрики загруженности дата центра, его вес повышается, что возвращает поток запросов к данному дата центру.

Таким образом интеграция данного подхода с встроенным алгоритмом Latency-based DNS от AWS заключается в использовании не только метрики latency, но и метрик загруженности сервера, т.е. "привлекательность" дата центра для направления в него запроса будет определена исходя из задержки и загруженности сервера, используя весовые коэффициенты для данных метрик.
Что-то похожее описано в [^25].

#### AWS Lambda
Скорее всего описанный алгоритм можно организовать с использованием AWS Lambda [^20]. 
Необходимо настроить обработчики (Lambda) на тригерры событий Amazon CloudWatch, которые срабатывают при перегрузке дата центров, и понижают их веса, и при нормализации загруженности дата центров, повышая их веса. 


### Часть 4. Расчет локальной нагрузки <a name="4"></a>
Внутри дата центра будут использоваться два слоя балансировки L4 и L7, что рекомендуется в [^13] для обеспечения отказоустойчивости.

L7-балансировка на основе NGNIX для голосового ассистента будет использована для:
- SSL терминация
- Вынесение авторизации на уровень NGNIX (при потенциальной необходимости появления в сервисе), при помощи написания расширений

Для обеспечения отказоустойчивости будет использована технология CARP, при падении одного из NGNIX, траффик будет перенаправлен на резервный.

L4-балансировка будет использована для распределения траффика между NGNIX, что повышает отказоустойчивость и решает проблему долгого нединамического перечитывания конфига NGNIX-ом.

#### Схема локальной балансировки
![локальная схема балансировки](/src/local.svg)
 
### Часть 5. Логическая схема БД <a name="5"></a>
Логическая схема БД представлена ниже:
![логическая схема бд](/src/logic_db1.svg)

Описание таблиц:
| Таблица                             | Описание       |
| ----------------------------------- | --------------- | 
| Users          | данные о пользователях  |
| Queries          | данные о запросах пользователей  |
| Sessions  | данные о сессиях пользователей  |

Память для таблицы Users может быть расчитана следующим образом:
- ID - 16 байт
- Login - 32 байт (верхняя оценка) 
- Password 10 байт [^14]

Умножая число пользователей на размер таблицы, получим:
$$500*10^6*(16+32+10)=27~Гбайт$$

Обращение к данной таблице происходит при авторизации, если предположить, что пользователь атворизуется раз в месяц, то RPS равен: $$500*10^6/(30*24*60*60)=192~запросов/секунду$$

Память для таблицы Queries может быть расчитана следующим образом:
- ID - 16 байт
- UserID - 16 байт
- QuerieText - 29 байт (средняя длина вопроса)  
- QreationDate - 4 байта 

Умножая число запросов в месяц на размер таблицы, получим:

$37.2*10^6*30*(16+16+29+4)=67.56~Мбайт$ - прирост размера таблицы за месяц

Обращение к данной таблице происходит при отправке поиксового запроса или запроса на музыку, т.е. RPS равен:
$$430+287=717~запросов/секунду$$

Память для таблицы Sessions может быть расчитана следующим образом:
- UserID - 16 байт
- Token - 16 байт 

Умножая число пользователей на размер таблицы, получим:
$$500*10^6*(16+16)=15~Гбайт$$

Обращение к данной таблице происходит при отправке поиского запроса или запроса на музыку, т.е RPS равен: $$430+287=717~запросов/секунду$$

| Таблица                             | Размер       |RPS|
| ----------------------------------- | --------------- |-| 
| Users          | $27~ГБайт$  |192|
| Queries          | $67.56~Мбайт$ (прирост в месяц)  |717|
| Sessions  | $15~ГБайт$  |717|

### Часть 6. Физическая схема БД. <a name="6"></a>
![физическая схема бд](/src/phys_db1.svg)
Для таблиц Users и Queries будет использована PostgreSQL, а для таблицы Sessions будет использован Redis.

#### Репликация
Каждая таблица будет иметь реплику, взаимодействие которой будет организовано по модели Master-Slave

#### Шардинг
Шардинг будет проводить по ID в таблице Users и UserID в таблице Queries, так чтобы данные об одном пользователи были физически на одном сервере

#### Патриционирование 
Для оптимизации работы базы данных необходимо выполнить партиционирование по дате создания в таблице Queries, что позволит добиться равномерного распределения данных внутри партиций

#### Индексы
PK индекс на ID в таблице Users, Unique индекс на Login, PK индексы на ID и CreationDate и FK индекс на UserID таблицы Queries 

#### Клиентские библиотеки
Работа с PostrgreSQL: 
- gorm.io/gorm
- gorm.io/driver/postgres

Работа с Redis:
- go-redis

#### Балансировака запросов / мультиплексирование подключений
Для обеспечения мультипликсирование соединений будем использовать pgBouncer

#### Схема резеврного копирования 
Будем использовать совместно full backup и incremental backup для создания полных копий и копий данных, изменившихся с момента создания последнего backup [^15]. 
Full backup будем производить раз в неделю, incremental backup раз в сутки.

### Часть 7. Алгоритм <a name="7"></a>
Алгоритм работы сервиса можно разделить на два этапа:
1. Обработка и распознавание речи
2. Определение намерения

#### Первый этап
Для решения задачи на каждом из этапов нужна специально обученная модель.

В процессе распознавания речи возникают некоторые трудности как обработка шумов, посторонних звуков и т.д., но оснавная проблема заключается в том, что говорящих может быть несколько. 
Из-за этого возникает задача выделения из нескольких голосов запроса, адресованного к голосовому ассистенту.

Решение данной задачи хорошо было описано и, видимо, уже использовано в статье [^21] для умных устройств.

В следующем абзаце будут приведены выдержки из данной статьи по поводу описания алгоритма решения задачи многих говорящих с дополнением про распознавание речи.

В общем случае, данную задачу можно решить с помощью выделения  каждого из N говорящих голосов (для чего используется модель Sepformer) и распознавания их вместе с исходной аудиозаписью (с помощью wav2vec, которая по данным с [^24] является наиболее быстрой), после чего встает задача классификации канала, который направлялся к голосовому ассистенту для чего используется библиотека CatBoost.

Таким образом на первом этапе решается три задачи:
1. Разделение голосов с помощью Sepformer
2. Распознавание речи каждого голоса и оригинальной записи с помощью wav2vec
3. Определение голоса, адрессованного ассистенту с помощью CatBoost

На выходе первого этапа мы получаем текст команды для голосового
ассистента.

#### Второй этап
Определение намерений это отдельная задача, которая решается при помощи других моделей и опирается на сценарии использования приложения, т.е. должны быть описаны основные сценарии использования умного ассистента (должны хранится где-то в конфиге), для того чтобы можно было правильно определять намерение пользователя.

Простой пример определения намерений приведен в статье про чат-бот [^22].

Основными сценариями умного голосового ассистента является установка музыки и поисковые запрос.

Основные намерения:
1. Для установки музыки могут быть использованы фразы:
    1. Поставь
    2. Включи
    3. Запусти
    и т.д.
2. При проигрывании трека можно повысить громкость:
    1. Погромче
    2. Громче
    3. Слишком тихо
    и т.д.
3. Аналогично для понижения громкости:
    1. Потише
    2. Тише
    3. Слишком громко
    и т.д.
4. Для переключения записи вперед:
    1. Поставь следующую
    2. Пропусти
    3. Дальше
    и т.д.
5. Аналогично для переключения записи назад:
    1. Поставь предыдущую
    2. Назад
    3. Верни старую
    и т.д.
6. Поисковой запрос:
    1. Найди
    2. Поищи
    3. Где находится
    4. Как пройти
    и т.д.

И другие возможные сценарии. 
На этих сценариях обучается модель, которая будет использована для определения намерения пользователя. 
В исследовании, проведенном в [^23], показывается, что хорошим решением является библиотека LUIS.

На выходе второго этапа мы получаем формальное команды (понятное машине), которую должен совершить голосовой ассистент.

### Часть 8. Технологии <a name="8"></a>
| Тенхология                             |Применение|
| ----------------------------------- | --------------- | 
| PostgreSQL  |Хранение данных, реплицирование, шардирование, бэкап|
| Go | Многопоточные неблокирующие сервера бекенда  |
| Redis | Быстрое key-value хранилище для сессий  |
|Kubernetes| Технология для автоматизации развертывания контейнеров, перезапуска, проверки работы, распределения по физ. серверам|
|Ngnix|L7 балансировщик нагрузки|
|PgBouncer|Мультиплексирование соединений к PostgreSQL|
|Amazon CloudWatch|Сбор метрик в реальном времени и обеспечение действий|
|Amazon Route 53|DNS балансировка (Latency-base)|
|AWS|Сервис облачных вычислений для интерации с Amazon CloudWatch и Amazon Route 53|
|Sepformer[^21]|Разделение голосов|
|wav2vec|Распознавание речи|
|CatBoost[^21]|Определение голоса, адресованного к голосовому ассистенту|
|LUIS|Определение намерения|


### Часть 9. Обеспечение отказоустойчивости <a name="9"></a>
#### База данных
Обеспечение отказоустойчивости базы данных реализуется при помощи реплицирования по модели Master-Slave и создания бекапов.
#### Балансировщик нагрузки NGNIX
Будет установлено несколько балансировщиков нагрузки NGNIX, каждый из которых будет находится в CARP-группе, т.е. если один из балансировщиков из пары выходит из строя, он подменяется резервным.
#### L4 Балансировка
Запросы на NGNIX будут балансироваться при помощи L4 балансировки, что позволяет обеспечить отказоустойчивость равной уровню отказоусточивости железа.
#### Несколько workerов
Будет несколько экземлпяров воркеров, что обеспечивает равномерно перераспределение нагрузки между воркерами, в случае отказа одного из них
#### Healthcheck нод Kubernetes
Автоматический перезапуск нод Kubernetes, когда они перестают отвечать [^16].

#### Принципы
- retry-запросы - отправка повторых запросов по timeout, обеспечивается при помощи NGNIX, позволяет решить проблему в случае, если один из воркеров перестал работать
- Graceful shutdown - обеспечение сохранения запросов в случае приостановки системы, поддерживается благодаря Kubernetes


### Часть 10. Схема проекта <a name="10"></a>
![схема проекта](/src/схема%20проекта.svg)
При помощи DNS определяется IP адрес дата центра к которому необходимо определить запрос, далее на слое L4 определяется NGNIX на который будет проксироваться запрос, надежность NGNIX определяется технологией CARP и присутствием нескольких NGNIX-серверов, далее NGNIX проксиует запрос на Application Server, при этом по таймауту запрос может быть переотправлен на другой application server, присутствие нескольких application server-ов обеспечивает равномерное распределение нагрузки и повышает отказоустойчивость. 
Application Server обращается к Redis и PostrgreSQL, надеждность которых обеспечивается моделью Master-Slave. 
акже для PostrgreSQL выполнено шардирование, что распределяет нагрузку на БД.

### Часть 11. Список серверов <a name="11"></a>
Для расчетов воспользуемся таблицой из [части три](#3):
|Тип запросов|RPS|Траффик|
|--|-----|-----|
|Поиск|$430~запрос/c$|$43~Гбит/c$|
|Музыка|$287~запрос/c$|$29~Гбит/c$|
|Суммарный|$717~запрос/c$|$72~Гбит/c$|

В [^26] приведена статистика, утверждающая, что пропускная способность NGNIX находится в районе $48~Гбит/c$, которая достигается на 16 ядрах процессора и не становится лучше с увеличением ядер.
Таким образом достаточно будет два NGNIX сервера на дата-центр:
|Ресурс|Значение|
|---|---|
|CPU|16|
|Сеть|$48~Гбит/c$|

Основную нагрузку на железо будут представлять модели работающие с речью, поэтому необходимо учитывать и это.
Согласно [^24] пропускная способность wav2vec составляет 126.2 на карте A5000, однако потребляет 19.4Gb RAM при объеме памяти в 24Gb [^27].

Средняя длина звука вопроса составляет $15.2~секунды$, т.е. в один запрос будет обработан библиотекой за $$15.2/126.2=0.12с$, чего достаточно для осуществления высокой пропускной способности сервера при работе на одной видеокарте.

Остальные библотеки могут использовать CPU, поэтому необходимо дополнительные ядра процессора по отношению к обработке запросов.
Вместо привычного 1 ядро на на 100 RPS будем брать 3 ядра на 100RPS с запасом (с учетом возможного усложения бизнес-логики).
Для RAM будем использовать расчеты 100MB на 100RPS.

Таким образом характеристики для Application Server:
|Ресурс|Значение|
|---|---|
|CPU|24|
|GPU|24GB|
|RAM|0.8GB|

В каждом дата центре необходимо поставить хотя бы по два сервера, для обеспечения отказоустойчивости.

Для PostgreSQL объем данных, накопленных за год, составляет примерно 25Гб, т.е. сервера объемом памяти 200Гб хватает с запасом на 5 лет.

С учетом того, что выполняется шардирование, необходимо хотя бы 3 экземпляра сервера, каждая из которых будет реплецироваться по модели Master-Slave. 
Т.е. на один дата центр приходится 6 серверов.

Таким образом характеристики для PostgreSQL Server:
|Ресурс|Значение|
|---|---|
|CPU|24|
|RAM|32GB|
|ROM|200GB|

Для Redis объем данных составляет примерно 15GB по хранению сессий.
Будет создана реплика по модели Master-Slave, т.е. нужно 2 сервера.

Тогда характеристики для сервера Redis:
|Ресурс|Значение|
|---|---|
|CPU|8|
|RAM|32GB|
|ROM|20GB|

Тогда итоговая таблица серверов на дата-центр:
|Тип сервера|Характеристики|Количество|
|---|---|--|
|NGNIX|16 CPU; 16 GB RAM|2|
|Application Server|24 CPU; 24 GB GPU, 0.8 GB RAM|2|
|PostrgreSQL Server|24 CPU; 32 GB RAM, 200 GB ROM|6|
|Redis Server|8 CPU; 32 GB RAM, 20 GB ROM|2|



### Список источников <a name="12"></a>
[^1]: [Статистика Google Assistant](https://tech.hindustantimes.com/tech/news/ces-2020-google-assistant-hits-500-million-users-new-set-of-features-announced-story-oKAGV1xsMrrAYPPigMEGxK-4.html)
[^2]: [Статистика голосовых помощников](https://serpwatch.io/blog/voice-search-statistics/)
[^3]: [Статистика по длине ответа на запросы](https://searchengines.guru/ru/articles/2048581)
[^4]: [Статистика по длине запроса](https://pr-cy.ru/news/p/6995-golosovoy-poisk-sovety-po-optimizatsii-kontenta-i-issledovanie)
[^5]: [Средняя скорость английской речи](https://multiurok.ru/blog/skorost-riechi.html)
[^6]: [Средняя длина английских слов](https://qna.habr.com/q/554389)
[^7]: [Рассчет объема звука](https://zftsh.online/articles/4857)
[^8]: [Стандартные значения объема звука от времени](http://abcibc.com/computer-notebook-gadget.php?art=4)
[^9]: [Исследовательская статья про использование голосовых помощников](https://www.researchgate.net/publication/332745214_Music_Search_and_IoT_How_People_Really_Use_Voice_Assistants/link/5ced7feea6fdcc18c8e9654d/download?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uIn19)
[^10]: [Рынок голосовых ассистентов по странам](https://medium.com/@foxymatveeva/journey-to-the-global-voice-market-the-us-europe-china-and-russia-8b47a4c3f8e)
[^11]: [Статистика использования голосовых ассистентов](https://www.demandsage.com/voice-search-statistics/)
[^12]: [Алгоритмы балансировки](https://aws.amazon.com/ru/what-is/load-balancing/)
[^13]: [L4 и L7 балансировка](https://habr.com/ru/companies/vk/articles/347026/)
[^14]: [Средний размер пароля](https://www.opennet.ru/opennews/art.shtml?num=53260)
[^15]: [Резервное копирование](https://www.ispsystem.ru/news/backup-101)
[^16]: [Работа с Kubernetes](https://habr.com/ru/articles/258443/)
[^17]: [Latency-base DNS от Amazon Route 53](https://www.techtarget.com/searchcloudcomputing/tutorial/How-latency-based-routing-works-in-Amazon-Route-53)
[^18]: [Amazon CloudWatch для метрик](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html)
[^19]: [Развертка Kubernetes на AWS](https://habr.com/ru/companies/otus/articles/774592/)
[^20]: [AWS Lambda](https://habr.com/ru/articles/457100/)
[^21]: [Распознавание речи нескольких говорящих](https://habr.com/ru/companies/sberdevices/articles/684228/)
[^22]: [Чат-бот определяющий намерения пользователя](https://habr.com/ru/articles/529590/)
[^23]: [Сравнение библиотек распознавания намерений](https://www.artefact.com/blog/nlu-benchmark-for-intent-detection-and-named-entity-recognition-in-call-center-conversations/)
[^24]: [Сравнение библиотек распознавания речи](https://deepgram.com/learn/benchmarking-top-open-source-speech-models)
[^25]: [Балансировка Badoo](https://highload.guide/blog/load-balancing-frontend-cluster.html)
[^26]: [Benchmarks для NGNIX](https://www.nginx.com/blog/testing-the-performance-of-nginx-and-nginx-plus-web-servers/)
[^27]: [Видеокарта A5000](https://www.regard.ru/product/425894/videokarta-nvidia-quadro-rtx-a5000-24gb-900-5g132-2500-000)